#!/usr/bin/python
# bean-add - A beancount transaction entry assistant
# Author: Simon Volpert <simon@simonvolpert.com>
# License: "Do what you feel is right, but don't be a jerk" public license.
# See the README.md file for additional information

usage = 'Usage: bean-add FILENAME'

import readline
import sys
import datetime
import subprocess
import os

# Process command line arguments
if len(sys.argv) < 2:
	sys.exit(usage)
elif sys.argv[1] == '-h' or sys.argv[1] == '--help':
	sys.exit(usage)

# Init transaction data
class data(object):
	# Journal/transactions
	journal = []
	saved = []
	file_name = sys.argv[1]
	defaults = {}
	restore = []
	# Completion
	accounts = []
	currencies = []
	tags = []
	vocab = []
	# Current transaction
	description = ''
	cur = ''
	balance = 0
	flag = False
	tag = 'bean-add'
	txid = -1
	date = datetime.date.today().isoformat()
	date_prompt = '%Y-%m-%d'
	# Statements
	statement = []
	statement_pattern = ' ! '
	statement_replacement = ' * '
	target = 0
	statement_currency = ''
	transaction_account = ''
	funding_account = ''
	# Options
	sort_by_date = True
	date_delimiter = '-'
	use_defaults = None
	paranoid_write = False

# Set global constants
tempfile = '/tmp/bean-add.%s.tmp.bnct' % os.environ['USER']

# Ask for confirmation: str(prompt) -> bool(result)
def confirm(prompt='', default_yes=None):
	# Unset completion
	data.vocab = []
	readline.set_completer_delims('')
	# Get a valid confirmation
	while True:
		ch = input(prompt).lower()
		if ch == '':
			if default_yes is None:
				continue
			ch = 'y' if default_yes else 'n'
		if ch == 'y':
			return True
		elif ch == 'n':
			return False

# Cast a number into the appropriate format: number -> int or rounded float
def cast_number(number):
	return int(number) if int(float(number)) == float(number) else round(float(number), 2)

# Condense whitespace and return a list
def condense(line):
	line = line.strip().split(' ')
	_data = []
	for i in line:
		if i.strip() != '':
			_data.append(i)
	return _data

# Read and process journal file
try:
	with open(data.file_name, 'r') as source_file:
		tx_file = source_file.read()
except:
	sys.exit('Could not open the file `%s`.' % data.file_name)

description = ''
for line in tx_file.split('\n'):
	line = line.strip()
	if line == '':
		# Transaction came out empty
		if description in data.defaults and data.defaults[description] == []:
			del(data.defaults[description])
		description = ''
		continue
	# Skip comments
	elif line.startswith(';'):
		continue
	_data = condense(line)
	try:
		# Attach transaction legs to previous description
		if _data[0] in data.accounts:
			data.defaults[description].append(_data[0])
			# Transaction leg has a currency sign
			if len(_data) == 3:
				_cur = _data.pop()
				if _cur not in data.currencies:
					data.currencies.append(_cur)
		# Add account name to account list
		elif _data[1] == 'open':
			data.accounts.append(_data[2])
		# Cache command data
		elif _data[1] == 'balance':
			data.defaults['__balance__'] = [_data[2]]
		elif _data[1] == 'pad':
			data.defaults['__pad__'] = [_data[2], _data[3]]
		# Record a description
		elif _data[1] in '!*':
			data.date_delimiter = _data[0][4]
			description = line[13:].split('#')[0].strip('" ')
			data.defaults[description] = []
			if '#' in line:
				for word in _data:
					if '#' in word:
						if not word[1:] in data.tags:
							data.tags.append(word[1:])
						data.defaults['__tag__'] = word[1:]
	except IndexError:
		continue

# Prepare file for transaction insertion
data.journal = tx_file.split('\n\n')
data.journal = [ i.strip() for i in data.journal ]
# Modification tracking
data.saved = data.journal.copy()
# Remove empty records
_badblocks = []
for i in range(len(data.journal)):
	if data.journal[i] == '':
		_badblocks.insert(0, i)
for i in _badblocks:
		del data.journal[i]

# Set up the completer
readline.parse_and_bind('tab: complete')

def complete(text, state):
	results = [x for x in data.vocab if x.startswith(text)] + [None]
	return results[state]

readline.set_completer(complete)

# Print some statistics
print('%s record(s) processed' % len(data.journal))
if len(data.accounts) > 0:
	print('%s account(s), %s unique description(s), %s currency sign(s), %s tag(s) loaded' % (len(data.accounts), len(data.defaults), len(data.currencies), len(data.tags)))
else:
	print('File contains no account definitions.')
	if not confirm('Proceed with editing? (y/N) ', False):
		sys.exit()
if data.journal != data.saved:
	print('Automatic normalizations applied.')
	data.saved = data.journal.copy()

# Date delimiter handling
if data.date_delimiter != '-':
	print('\nWarning: Non-standard date delimiter.')
	data.date = data.date.replace('-', data.date_delimiter)
	data.date_prompt = data.date_delimiter.join(['%Y', '%m', '%d'])

# Init date and currencies
data.cur = data.currencies[0]

# Insert a transaction in an appropriate place in the file: str(transaction) -> int(index)
def insert_transaction(tx):
	_found = False
	for _txid in range(len(data.journal)):
		# Ignore records that don't start with a date
		if data.journal[_txid][0] not in '0123456789':
			continue
		# Seek forward to first bigger date
		if data.journal[_txid][0:10] > tx[0:10]:
			_found = True
			break
	if _found and data.sort_by_date:
		data.journal.insert(_txid, tx)
	else:
		# If not found, insert at the end of file
		_txid = len(data.journal)
		data.journal.append(tx)
	print('\nTransaction added as record %s\n\n%s' % (_txid, tx))
	data.txid = _txid

# Date from string wrapper: str(date) -> date(date)
def strpdate(d):
	return datetime.datetime.strptime(d, data.date_prompt).date()

# Read and validate a date: str(default) -> str(date)
def read_date(default):
	# Unset completion
	data.vocab = []
	readline.set_completer_delims('')
	# Get a valid date
	while True:
		reading = input('Enter transaction date (%s, or +/-days) [%s]: ' % (data.date_prompt, default))
		# Accepting the default
		if reading == '':
			return default
		date = strpdate(default)
		# Relative date
		if reading.startswith('+') or reading.startswith('-'):
			try:
				date += datetime.timedelta(int(reading))
			except ValueError:
				continue
		# Absolute date
		else:
			try:
				date = strpdate(reading)
			except ValueError:
				continue
		return date.isoformat()

# Read a description -> str(description)
def read_description():
	# Set completion
	data.vocab = data.defaults.keys()
	readline.set_completer_delims('')
	# Get a non-empty description
	while True:
		reading = input('Enter transaction description [%s]: ' % data.description).strip(' "')
		if reading == '':
			if data.description != '':
				return data.description
			else:
				return None
		else:
			data.description = reading
			return reading

# Read a valid account name
def read_account():
	# Read a valid account
	while True:
		# Set completion
		data.vocab = data.accounts
		readline.set_completer_delims('')
		reading = input('Enter an account name (tab to complete, enter to fininsh): ')
		if reading == '':
			return None
		# Add new account option
		if reading not in data.accounts:
			if not confirm('The account `%s` is not in the journal file. Add it? (Y/n) ' % reading, True):
				continue
			insert_transaction('%s open %s' % (data.date, reading))
			print()
			data.accounts.append(reading)
		return reading

# Normalize amounts with unnecessary decimal places
# number, rounding precision -> string
def undecimal(number, precision):
	try:
		number = cast_number(number)
	except ValueError:
		print('\nThis is not a number.')
		raise KeyboardInterrupt
	if type(number) == type(0.0):
		number = round(number, precision)
		if len(str(number).split('.')[1]) == 1:
			number = str(number) + '0'
	return str(number)

# Read and normalize transaction amount
def read_amount(account):
	# Set completion
	data.vocab = data.currencies
	readline.set_completer_delims(' ')
	# Read an amount
	if account in data.accounts:
		account = '`%s`' % account
	amount = input('Enter the amount for %s (including currency symbol) [%s %s]: ' % (account, data.balance, data.cur))
	if amount == '':
		amount = [data.balance, data.cur]
	else:
		amount = amount.split()
	# Process currency sign
	if len(amount) == 1:
		amount.append(data.cur)
	else:
		data.cur = amount[-1]
	# Normalize numbers and process conversion rate
	amount[0] = undecimal(amount[0], 2)
	if '@' in amount:
		amount[-2] = undecimal(amount[-2], 3)
		data.balance -= float(amount[0]) * float(amount[-2])
	else:
		data.balance -= float(amount[0])
	data.balance = cast_number(data.balance)
	# Finalize and return
	return ' '.join(amount)

# Toggle transaction flag
def toggle_flag():
	if data.txid < 0:
		print('\nNothing to flag, no current transaction.')
		return
	if ' ! ' in data.journal[data.txid]:
		data.flag = True
	else:
		data.flag = False
	if data.flag:
		data.flag = False
		data.journal[data.txid] = data.journal[data.txid].replace(' ! ', ' * ')
		print('\nTransaction flag unset.')
	else:
		data.flag = True
		data.journal[data.txid] = data.journal[data.txid].replace(' * ', ' ! ')
		print('\nTransaction flag set.')
	print()
	print(data.journal[data.txid])

# Add or remove transaction tags
def add_remove_tag():
	if data.txid < 0:
		print('\nNothing to tag, no current transaction.')
		return
	# Set completion
	data.vocab = data.tags
	readline.set_completer_delims('')
	# Get and normalize a tag
	try:
		_tag = input('Enter a tag [%s]: ' % data.defaults['__tag__'])
	except KeyboardInterrupt:
		print('\nTagging cancelled.')
		return
	_tag = _tag.strip('# ')
	if _tag == '':
		_tag = data.defaults['__tag__']
	else:
		data.defaults['__tag__'] = _tag
	# If the tag is already there, offer to remove it instead
	if '#' + _tag in data.journal[data.txid]:
		if confirm('\nThe transaction already has this tag. Remove it? (Y/n) ', True):
			data.journal[data.txid] = data.journal[data.txid].replace(' #%s' % _tag, '')
		else:
			print('\nTagging cancelled.')
			return
	# Apply the tag (using two different methods)
	else:
		_transaction = data.journal[data.txid].replace('"\n', '" #%s\n' % _tag)
		if _transaction == data.journal[data.txid]:
			_transaction = data.journal[data.txid].replace('" #', '" #%s #' % _tag)
		if _transaction == data.journal[data.txid]:
			print('\nCannot add tags to special transactions.')
			return
		data.journal[data.txid] = _transaction
	print()
	print(data.journal[data.txid])

# Seek to a specific record in the journal file
def seek_to_transaction(autoseek=None):
	while True:
		if autoseek is None:
			# Manual seeking input
			if data.txid >= 0:
				print('\nCurrently at record %s.' % data.txid)
			else:
				print('\nNo current record.')
			try:
				reading = input('Enter record number (0-%s, or +/-COUNT): ' % (len(data.journal) - 1))
			except KeyboardInterrupt:
				print('\nSeeking cancelled.')
				return
		else:
			reading = autoseek
		try:
			_txid = int(reading)
		except ValueError:
			print('\nSeeking cancelled.')
			return
		if reading.startswith('+') or reading.startswith('-'):
			if data.txid == -1:
				if autoseek is not None:
					print('\nNo current record.')
					return
				else:
					print('\nSeeking cancelled.')
					return
			else:
				_txid += data.txid
		if _txid < 0:
			if autoseek is not None:
				print('\nYou are at the first record.')
				return
			else:
				print('\nSeeking cancelled.')
				return
		elif _txid > len(data.journal) - 1:
			if autoseek is not None:
				print('\nYou are at the last record.')
				return
			else:
				print('\nSeeking cancelled.')
				return
		else:
			break
	print('\nRecord %s:\n' % _txid)
	print(data.journal[_txid])
	data.txid = _txid

# Return a list of txids which contain all of the passed strings
def tx_lookup(patterns, prune_txids=[]):
	if type(patterns) == type(''):
		patterns = [patterns]
	results = []
	for i in range(len(data.journal)):
		if i not in prune_txids:
			match = True
			for pattern in patterns:
				# Use an AND keyword joining
				if pattern not in data.journal[i]:
					match = False
					break
			if match:
				results.append(i)
	return results

# Find transactions that contain a string
def find_transactions():
	try:
		reading = input('Enter a search string: ').strip('\n')
	except KeyboardInterrupt:
		print('Lookup cancelled.')
		return
	if reading == '':
		print('Lookup cancelled.')
		return
	for i in tx_lookup(reading):
		print('[%s]	%s' % (i, data.journal[i].split('\n')[0]))

# Get default accounts for a transaction
def get_default_accounts(description):
	if description in data.defaults:
		print('Previously used accounts for this transaction:')
		for _account in data.defaults[description]:
			print('\t%s' % _account)
		print()
		_use = confirm('Use these accounts? (Y/n) ', True) if data.use_defaults is None else data.use_defaults
		if _use:
			return data.defaults[description]
		else:
			return []
	else:
		return []

# Enter a normal transaction
def read_normal_transaction():
	output = ''
	_transaction = []
	data.balance = 0
	data.date = read_date(data.date)
	description = read_description()
	if description is None:
		print('\nTransaction entry aborted.')
		return
	else:
		output += '%s %s "%s"\n' % (data.date, '!' if data.flag else '*' , description)
	defaults = get_default_accounts(description)
	while True:
		if len(defaults) > 0:
			account = defaults.pop(0)
		else:
			account = read_account()
			if account is None:
				if data.balance != 0:
					if not confirm('\nThe transaction is unbalanced! Really finish? (y/N) ', False):
						continue
				break
		_transaction.append(account)
		amount = read_amount(account)
		if amount.startswith('0 '):
			print('Removing zero-amount `%s` from transaction.' % account)
			del(_transaction[ -1])
		else:
			output += '	%s %s\n' % (account, amount)
	data.defaults[description] = _transaction
	if _transaction == []:
		print('\nTransaction entry aborted.')
	else:
		insert_transaction(output.strip())

# Read a balance assertion transaction
def read_balance_transaction():
	print('\nAdding a new balance assertion.')
	data.date = read_date(data.date)
	defaults = get_default_accounts('__balance__')
	if defaults == []:
		account = read_account()
		data.defaults['__balance__'] = [account]
	else:
		account = defaults[0]
	data.balance = 0
	amount = read_amount(account)
	output = '%s balance %s %s' % (data.date, account, amount)
	insert_transaction(output)

# Read a pad statement
def read_pad_transaction():
	print('\nAdding a new pad statement.')
	data.date = read_date(data.date)
	defaults = get_default_accounts('__pad__')
	if defaults == []:
		account1 = read_account()
		account2 = read_account()
		data.defaults['__pad__'] = [account1, account2]
	else:
		account1, account2 = defaults
	output = '%s pad %s %s' % (data.date, account1, account2)
	insert_transaction(output)

# Read a note statement
def read_note_transaction():
	# Unset completion
	data.vocab = []
	readline.set_completer_delims('')
	print('\nAdding a new note statement.')
	data.date = read_date(data.date)
	defaults = get_default_accounts('__note__')
	if defaults == []:
		account = read_account()
		data.defaults['__note__'] = [account]
	else:
		account = defaults[0]
	description = input('Enter the note text: ').strip(' "')
	output = '%s note %s "%s"' % (data.date, account, description)
	insert_transaction(output)

# Edit the current transaction with an external editor
def edit_transaction():
	if 'EDITOR' not in os.environ or os.environ['EDITOR'] == '':
		print('\nThe $EDITOR environmental variable is not set, editing unavailable.')
		return
	if data.txid < 0:
		print('\nNothing to edit, no current record.')
		return
	with open(tempfile, 'w') as tmp_file:
		tmp_file.write(data.journal[data.txid])
	try:
		subprocess.call([os.environ['EDITOR'], tempfile])
	except:
		print('\nCould not start the editor: %s\n' % sys.exc_info()[1])
	with open(tempfile, 'r') as tmp_file:
		_tx = ''.join(tmp_file.readlines())
	if _tx == data.journal[data.txid]:
		print('Nothing changed.')
	else:
		data.journal[data.txid] = _tx
		print('Record updated.')
	os.unlink(tempfile)

# Print the context to the current transaction (+-10 transactions)
def print_journal():
	if data.txid == -1:
		print('\nNo current record.')
		return
	start = max(data.txid - 10, 0)
	end = min(data.txid + 10, len(data.journal))
	for tx in range(start, end):
		tx_string = data.journal[tx].split('\n')[0]
		tx_number = '>>>>>>>' if tx == data.txid else '[%s]' % tx
		print('%s	%s' % (tx_number, tx_string))

# Calculate the balance of an account
def calculate_balance(account, txlist=None):
	if txlist is None:
		txlist = list(range(len(data.journal)))
	amounts = {}
	for currency in data.currencies:
		amounts[currency] = 0
	for tx in txlist:
		lines = data.journal[tx].split('\n')
		line = condense(lines[0])
		# If the record is a balance statement, use that
		if len(line) == 5 and line[1] == 'balance' and line[2] == account:
			amounts[line[4]] = cast_number(line[3])
			continue
		# Else, add the amount to the balance
		for line in lines[1:]:
			line = condense(line)
			# Transaction leg flags are irrelevant
			if line[0] == '!':
				del(line[0])
			# Line is too short to be useful
			if len(line) < 3:
				if line[0] == account:
					print('Warning: Implied amounts are not supported! Skipping record %s.' % tx)
				continue
			if line[0] == account:
				amounts[line[2]] = cast_number(amounts[line[2]] + float(line[1]))
	return amounts

# Count and print the balances for an account
def print_account_balances():
	try:
		account = read_account()
	except KeyboardInterrupt:
		print('\nCancelled.')
		return
	amounts = calculate_balance(account)
	print('\nBalances for %s:' % account)
	for currency in data.currencies:
		if amounts[currency] != 0:
			print('%s %s' % (amounts[currency], currency))

# Verify a statement
def verify_statement():
	# If wasn't working on a statement before
	if data.target == 0 or not confirm('Continue ongoing statement verification? (Y/n) ', True):
		try:
			data.statement = []
			print('\nEnter the account the statement refers to.')
			data.transaction_account = read_account()
			print('\nEnter the account which funds the statement.')
			data.funding_account = read_account()
			print()
			amount = read_amount('the statement')
			data.target = cast_number(amount.split()[0])
			if data.target == 0:
				raise KeyboardInterrupt
			data.statement_currency = amount.split()[1]
		except KeyboardInterrupt:
			print('\nCancelled.')
			return
	while True:
		# Tally the balance
		balance = abs(calculate_balance(data.transaction_account, data.statement)[data.statement_currency])
		print('\nTotal: %s %s (target: %s %s, difference: %s %s)' % (balance, data.statement_currency, data.target, data.statement_currency, cast_number(balance - data.target), data.statement_currency))
		if balance == data.target:
			break
		transactions = tx_lookup([data.transaction_account, data.statement_pattern], data.statement)
		print()
		# List matching records
		for tx in transactions:
			a = [data.journal[tx].split('\n')[0]]
			for l in data.journal[tx].split('\n'):
				if data.transaction_account in l:
					a.append(condense(l)[1])
					a[1] = abs(cast_number(a[1]))
			print('[%s]	%s	%s %s' % (tx, a[0], a[1], data.statement_currency)) # TODO space padding
		# Select records to add
		print('\nSelect records to add to the statement. Type a record number already on the statement to remove it.')
		try:
			reading = int(input('Enter a record number: ').strip())
			if reading < 0 or reading > len(data.journal) -1:
				raise ValueError
		except ValueError:
			print('\nInvalid record number.')
			continue
		except KeyboardInterrupt:
			print('\n\nPostponing statement verification.')
			return
		if reading in data.statement:
			data.statement.remove(reading)
		else:
			data.statement.append(reading)
			data.statement.sort()
	# Modify the journal
	if confirm('Commit statement to journal? (Y/n) ', True):
		try:
			date = read_date(data.date)
			desc = read_description()
		except KeyboardInterrupt:
			print('Postponing statement verification.')
			return
		print('\nSetting transaction flags.')
		for tx in data.statement:
			data.journal[tx] = data.journal[tx].replace(data.statement_pattern, data.statement_replacement)
		output = '%s * "%s"\n	%s %s %s\n	%s %s %s' % (date, desc, data.funding_account, undecimal(balance * -1, 2), data.statement_currency, data.transaction_account, undecimal(balance, 2), data.statement_currency)
		insert_transaction(output)
		# Mark the verification as finished
		data.target = 0

# Main data entry loop
print('\nChanges stay in memory until you [w]rite them out.')
print('Type `h` or `?` for a list of available commands.')

while True:
	if data.paranoid_write and data.journal != data.saved:
		cmd = 'w'
	else:
		try:
			cmd = input('\nEnter command (h for help) ')
		except KeyboardInterrupt:
			cmd = 'q'
	if cmd in ['w', 'wq']:
		with open(data.file_name, 'w') as source_file:
			source_file.write('\n\n'.join(data.journal) + '\n')
			print('\n%s record(s) written' % len(data.journal))
			data.saved = data.journal.copy()
		if cmd == 'wq':
			sys.exit()
	elif cmd == 'q':
		if data.journal != data.saved:
			if not confirm('The journal file was modified. Do you really want to DESTROY ALL CHANGES and quit? (y/N) ', False):
				continue
		elif data.target != 0:
			if not confirm('Statement verification in progress. Do you really want to DESTROY ALL CHANGES and quit? (y/N) ', False):
				continue
		sys.exit()
	elif cmd == 'c':
		with open(tempfile, 'w') as tmp_file:
			tmp_file.write('\n\n'.join(data.journal) + '\n')
		try:
			subprocess.call(['bean-check', tempfile])
		except:
			print('\nCould not start the validator: %s' % sys.exc_info()[1])
		else:
			print('\nValidation finished.')
		os.unlink(tempfile)
	elif cmd == 'n':
		try:
			read_normal_transaction()
		except KeyboardInterrupt:
			print('\nTransaction entry cancelled.')
	elif cmd == 'B':
		try:
			read_balance_transaction()
		except KeyboardInterrupt:
			print('\nTransaction entry cancelled.')
	elif cmd == 'P':
		try:
			read_pad_transaction()
		except KeyboardInterrupt:
			print('\nTransaction entry cancelled.')
	elif cmd == 'N':
		try:
			read_note_transaction()
		except KeyboardInterrupt:
			print('\nTransaction entry cancelled.')
	elif cmd == 'f':
		toggle_flag()
	elif cmd == 't':
		add_remove_tag()
	elif cmd == 's':
		seek_to_transaction()
	elif cmd == 'sa':
		seek_to_transaction('-1')
	elif cmd == 'sd':
		seek_to_transaction('+1')
	elif cmd == 'sq':
		seek_to_transaction('0')
	elif cmd == 'se':
		seek_to_transaction(str(len(data.journal) - 1))
	elif cmd == 'l':
		find_transactions()
	elif cmd == 'r':
		if data.txid >= 0:
			data.restore.append(data.journal.pop(data.txid))
			print('\nDeleted record %s' % data.txid)
			if data.txid >= len(data.journal):
				data.txid -= 1
		else:
			print('\nNothing to delete, no current transaction.')
	elif cmd == 'u':
		if len(data.restore) > 0:
			insert_transaction(data.restore.pop())
		else:
			print('\nNothing to undo, the restore buffer is empty.')
	elif cmd == 'e':
		edit_transaction()
	elif cmd == 'j':
		print_journal()
	elif cmd == 'b':
		print_account_balances()
	elif cmd == 'v':
		verify_statement()
	elif cmd == 'o':
		print('Available option commands:')
		print('os	sort transactions by date (%s)' % ('enabled' if data.sort_by_date else 'disabled'))
		print('oa	reuse last used accounts in new transactions (%s)' % ('ask' if data.use_defaults is None else 'always' if data.use_defaults else 'never'))
		print('ow	write journal after every change (%s)' % ('enabled' if data.paranoid_write else 'disabled'))
	elif cmd == 'os':
		data.sort_by_date = not data.sort_by_date
		print('\nSorting by date %s.' % ('enabled' if data.sort_by_date else 'disabled'))
	elif cmd == 'oa':
		data.use_defaults = None if data.use_defaults == False else not data.use_defaults
		print('\nThe policy on reusing accounts for new transactions is now `%s`.' % ('ask' if data.use_defaults is None else 'always' if data.use_defaults else 'never'))
	elif cmd == 'ow':
		data.paranoid_write = not data.paranoid_write
		print('\nWriting journal after every change is %s.' % ('enabled' if data.paranoid_write else 'disabled'))
	elif cmd == 'h' or cmd == '?':
		print('''Available commands:
n	new transaction
f	toggle transaction flag
t	add or remove tags
s	seek to another record
sa	seek one record forward
sd	seek one record backwards
sq	seek to the first record
se	seek to the last record
l	look up transactions containing a string
j	show the context of the current transaction
b	show the balance of an account
r	remove the current transaction
u	undo transaction removal
e	edit the current transaction with your preferred editor
v	verify a statement
B	new balance assertion
P	new pad statement
N	new note statement
c	run bean-check on the journal file
o	view or change options
w	write journal file
q	quit
wq	write journal file and quit immediately
h,?	show this help message''')
	else:
		print('Unknown command.')
