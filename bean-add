#!/usr/bin/python
# bean-add - A beancount transaction entry assistant
# Author: Simon Volpert <simon@simonvolpert.com>
# License: "Do what you feel is right, but don't be a jerk" public license.
# See the README.md file for additional information

import readline
import sys
import datetime

usage = 'Usage: bean-add FILENAME'

# Process command line arguments
if len(sys.argv) < 2:
	print(usage)
	sys.exit(1)

if sys.argv[1] == '-h' or sys.argv[1] == '--help':
	print(usage)
	sys.exit()
elif len(sys.argv) < 2:
	print(usage)
	sys.exit(1)

# Init transaction data
class data(object):
	# Journal/transactions
	array = []
	saved = []
	defaults = {}
	# Completion
	accounts = []
	commands = ['balance']
	currencies = []
	vocab = []
	# Current transaction
	description = ''
	cur = ''
	balance = 0
	flag = False
	tag = False
	txid = -1

# Ask for confirmation: str(prompt) -> bool(result)
def confirm(prompt=''):
	# Unset completion
	data.vocab = []
	readline.set_completer_delims('')
	# Get a valid confirmation
	while True:
		ch = input(prompt).lower()
		if ch == 'y':
			return True
		elif ch == 'n':
			return False

# Read and process journal file
with open(sys.argv[1], 'r') as source_file:
	tx_file = source_file.read()

description = ''
for line in tx_file.split('\n'):
	line = line.strip()
	if line == '':
		# Transaction came out empty
		if description in data.defaults and data.defaults[description] == []:
			del(data.defaults[description])
		description = ''
		continue
	# Skip comments
	elif line.startswith(';'):
		continue
	_data = line.split(' ')
	try:
		# Attach transaction legs to previous description
		if _data[0] in data.accounts:
			data.defaults[description].append(_data[0])
			# Transaction leg has a currency sign
			if len(_data) == 3:
				_cur = _data.pop()
				if _cur not in data.currencies:
					data.currencies.append(_cur)
		# Add account name to account list
		elif _data[1] == 'open':
			data.accounts.append(_data[2])
		# Cache command data
		elif _data[1] in data.commands:
			data.defaults[_data[1]] = [_data[2]]
		# Record a description
		elif _data[1] in '!*':
			description = line[13:].split('#')[0].strip('" ')
			data.defaults[description] = []
	except IndexError:
		continue

# Prepare file for transaction insertion
data.array = tx_file.split('\n\n')
data.saved = data.array.copy()
_badblocks = []
for i in range(len(data.array)):
	data.array[i] = data.array[i].strip()
	if data.array[i] == '':
		_badblocks.insert(0, i)
for i in _badblocks:
		del data.array[i]

# Set up the completer
readline.parse_and_bind("tab: complete")

def complete(text, state):
	results = [x for x in data.vocab if x.startswith(text)] + [None]
	return results[state]

readline.set_completer(complete)

# Print some statistics
print('Read %s block(s) of data' % len(data.array))
if len(data.accounts) > 0:
	print('%s account(s), %s unique description(s), %s currency sign(s) loaded' % (len(data.accounts), len(data.defaults), len(data.currencies)))
	print()
else:
	print('File contains no account definitions.')
	if not confirm('Proceed with editing? (y/n) '):
		sys.exit()

# Init date and currencies
date = datetime.date.today().isoformat()
data.cur = data.currencies[0]

# Insert a transaction in an appropriate place in the file: str(transaction) -> int(index)
def insert_transaction(tx):
	for tx_index in range(len(data.array)):
		# Ignore comments
		if data.array[tx_index].startswith(';'):
			continue
		# Seek forward to first bigger date
		if data.array[tx_index][0:10] > tx[0:10]:
			data.array.insert(tx_index, tx)
			print('\nTransaction added at block %s' % tx_index)
			return tx_index
	# If not found, insert at the end of file
	if ( tx_index + 1 ) == len(data.array):
		tx_index += 1
		data.array.append(tx)
	print('\nTransaction added at block %s' % tx_index)
	return tx_index

# Date from string wrapper: str(date) -> date(date)
def strpdate(d):
	return datetime.datetime.strptime(d, '%Y-%m-%d').date()

# Read and validate a date: str(default) -> str(date)
def get_date(default):
	# Unset completion
	data.vocab = []
	readline.set_completer_delims('')
	# Get a valid date
	while True:
		reading = input('Enter transaction date (%%Y-%%m-%%d, or +/-days) [%s]: ' % default)
		# Accepting the default
		if reading == '':
			return default
		date = strpdate(default)
		# Relative date
		if reading.startswith('+') or reading.startswith('-'):
			try:
				date += datetime.timedelta(int(reading))
			except ValueError:
				continue
		# Absolute date
		else:
			try:
				date = strpdate(reading)
			except ValueError:
				continue
		return date.isoformat()

# Read a description -> str(description)
def get_description():
	# Set completion
	data.vocab = data.defaults.keys()
	readline.set_completer_delims('')
	# Get a non-empty description
	while True:
		reading = input('Enter transaction description (or `balance`) [%s]: ' % data.description).strip(' "')
		if reading == '':
			if data.description != '':
				return data.description
			else:
				return None
		else:
			data.description = reading
			return reading

# Read a valid account name
def get_account():
	# Read a valid account
	while True:
		# Set completion
		data.vocab = data.accounts
		readline.set_completer_delims('')
		reading = input('Enter account name (tab to complete, enter to fininsh): ')
		if reading == '':
			return None
		# Add new account option
		if reading not in data.accounts:
			if not confirm('The account `%s` is not in the journal file. Add it? (y/n) ' % reading):
				continue
			print()
			insert_transaction('%s open %s' % (date, reading))
			data.accounts.append(reading)
		return reading

# Read and normalize transaction amount
def get_amount():
	# Set completion
	data.vocab = data.currencies
	readline.set_completer_delims(' ')
	# Read an amount
	amount = input('Enter amount for `%s` (including currency symbol) [%s %s]: ' % (account, data.balance, data.cur))
	if amount == '':
		amount = '%s %s' % (data.balance, data.cur)
	# Normalize entries with unneeded decimal places
	amt = float(amount.split()[0])
	if amt == int(amt):
		amount = '%s %s' % (int(amt), data.cur)
	if data.balance == 0:
		data.balance = amt * -1
	else:
		data.balance -= amt
	data.balance = int(data.balance) if data.balance == int(data.balance) else data.balance
	# Normalize amounts with one decimal place
	amt = amount.split()[0]
	_b = amt.split('.')
	if len(_b) > 1 and len(_b[1]) == 1:
		_b[1] += '0'
		amt = '.'.join(_b)
		amount = ' '.join([amt, data.cur])
	# Detach currency sign for reuse
	if len(amount.split()) == 1:
		amount += ' ' + data.cur
	else:
		data.cur = amount.split().pop()
	return amount

# Toggle transaction flag
def toggle_flag(tx_index):
	if data.flag:
		data.flag = False
		data.array[tx_index] = data.array[tx_index].replace(' ! ', ' * ')
	else:
		data.flag = True
		data.array[tx_index] = data.array[tx_index].replace(' * ', ' ! ')


# Main data entry loop
cmd = ''
last_message = 'Type `h` for list of available commands.'
while True:
	if last_message != '':
		print()
		print(last_message)
		print()
	if data.txid >= 0:
		print()
		print(data.array[data.txid])
		print()
	while True:
		#cmd = get_command(['nwqh']) # todo
		try:
			cmd = input('\nEnter command (nftwq or h) ')
		except KeyboardInterrupt:
			cmd = 'q'
		if cmd == 'w':
			with open(sys.argv[1], 'w') as source_file:
				source_file.write('\n\n'.join(data.array) + '\n')
				last_message = '%s block(s) written' % len(data.array)
				data.saved = data.array.copy()
		elif cmd == "q":
			if data.array != data.saved:
				if not confirm('Transaction data was modified. Really quit? (y/n) '):
					continue
			print('\nRemember that there is no input validation whatsoever! Please run `bean-check` and correct any errors manually.')
			sys.exit()
		elif cmd == "n":
			data.tag = False
			break # todo
		elif cmd == 'f':
			toggle_flag(data.txid)
			last_message = 'Flag toggled.'
			break
		elif cmd == 't':
			if data.txid >= 0:
				last_message = 'Nothing to tag, no current transaction.'
				continue
			if data.tag:
				data.tag = False
				data.array[data.txid] = data.array[data.txid].replace('" #bean-add\n', '"\n')
				last_message = 'Tag removed.'
			else:
				data.tag = True
				data.array[data.txid] = data.array[data.txid].replace('"\n', '" #bean-add\n')
				last_message = 'Tag added.'
			break
		elif cmd == "h":
			last_message = '''Available commands:
n	new transaction
f	toggle transaction flag
t	tag the transaction for later review
w	write journal file
q	quit
h	show this help'''
			last_message = '' # todo
	if cmd != 'n':
		continue
	last_message = ''
	output = ''
	definitions = ''
	defaults = []
	_transaction = []
	data.balance = 0
	try:
		date = get_date(date)
		description = get_description()
	except KeyboardInterrupt:
		last_message = 'Transaction entry aborted.'
		continue
	if description is None:
		last_message = 'Transaction entry aborted.'
		continue
	elif description == 'balance':
		print('\nBalance assertion mode.')
	else:
		output += '%s %s "%s"\n' % (date, '!' if data.flag else '*' , description)
	if description in data.defaults:
		print('Previously used accounts for this transaction:')
		defaults = data.defaults[description]
		for _account in defaults:
			print('\t%s' % _account)
		print()
		try:
			if not confirm('Use these accounts? (y/n) '):
				defaults = []
		except KeyboardInterrupt:
			last_message = 'Transaction entry aborted.'
			continue
	while True:
		if len(defaults) > 0:
			account = defaults[0]
			del(defaults[0])
		else:
			try:
				account = get_account()
			except KeyboardInterrupt:
				last_message = 'Transaction entry aborted.'
				continue
			if account is None:
				break
		_transaction.append(account)
		try:
			amount = get_amount()
		except KeyboardInterrupt:
			last_message = 'Transaction entry aborted.'
			continue
		if description == 'balance':
			output += '%s %s %s %s\n' % (date, description, account, amount)
			break
		else:
			output += '	%s %s\n' % (account, amount)
	data.defaults[description] = _transaction
	if _transaction == []:
		last_message = 'Transaction entry aborted.'
	else:
		data.txid = insert_transaction('\n'.join([definitions, output]).strip())
